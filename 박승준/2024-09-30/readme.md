1. 이 문제를 선택한 이유를 알려주세요(간단하게 설명해도 좋아요)
답) 오랜만에 푸는 알고리즘 문제라 적당히 풀 수 있는 문제를 찾아서 선택했습니다..!!

2. 문제의 난이도는 어떻게 느껴지셨나요?
답) 문제를 이해하는데 시간이 좀 걸렸고, 생각보다 어려워서 오랜 시간이 걸렸습니다...

3. 문제를 처음 봤을 때 어떻게 접근하셨나요?
답) 일단 사탕 위치부터 바꿔야겠다 생각했던 것 같습니다

4. 알고리즘 설계하는 데 걸린 시간은 어느 정도였나요?
답) 1시간정도 걸렸던 것 같아요

5. 문제 해결 시 어려운 점이 있었나요? 있었다면, 어떻게 해결했나요?
답) 사탕 위치를 바꾼 후에 최댓값을 저장한 후, 다음번 비교를 할 때 사탕 위치를 원래대로 되돌려야 한다는 점을 생각 못해서 좀 오래걸렸습니다  

6. 코드의 주요 부분을 간단히 설명해주세요
답) 3085.java 9번째 줄의 getMaxCandies 함수에서는 모든 행과 열 중 최대로 먹을 수 있는 사탕 개수를 알기 위해서 행에서 연속된 색깔의 사탕이 있다면 rowCount를 1씩 증가시키며 maxCandies와 비교해 큰 값을 maxCandies로, 열에서는 cowCount를 1씩 증가시켜 maxCandies와 비교해 큰 값을 maxCandies로 지정했습니다. 50번째 줄부터는 배열의 모든 인덱스를 탐색해 인접한 사탕의 위치를 바꾸고 getMaxCandies 함수를 호출해 최댓값을 계산한 후 다시 초기 상태로 되돌려 주었습니다.


7. 코드를 최적화 했다면 어떤 목적으로 최적화를 하셨나요?
답) 최적화는 안했던 것 같습니다.

8. 코드를 테스트 할 때 어떤 케이스를 고려했나요?
답) 모든 케이스에서 올바른 출력값이 나오도록 계속 확인했던 것 같습니다



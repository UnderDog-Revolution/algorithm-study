1. 이 문제를 선택한 이유를 알려주세요(간단하게 설명해도 좋아요)
   답) 싸피도 신청했겠다,, 코테 문제 수준한번 볼려고

2. 문제의 난이도는 어떻게 느껴지셨나요?
   답) SWEA D2 (D1~D8 중에서)

3. 문제를 처음 봤을 때 어떻게 접근하셨나요?
   답) 배열로 입력을 받고, 최대값을 찾아서 순차적으로 원소들의 값과의 차익을 구해서 모두 합하려고 했음 

4. 알고리즘 설계하는 데 걸린 시간은 어느 정도였나요?
   답) 30분. 코드 자체는 간단, 어떻게 접근하냐에 따라서 걸리는 시간이 크게 다를 듯

5. 문제 해결 시 어려운 점이 있었나요? 있었다면, 어떻게 해결했나요?
   답) 결론은 아래에 적어두었습니닷!
   분명 D2레벨이라고 했는데 정답률이 33퍼라 궁금해서 도전해보게 되었는데, 처음부터 어떻게 접근을 해야할지 고민되었다.
   처음에는, 각 매매가를 배열로 입력받아서, 순차적으로 그 값들을 최대값 원소와 계산해서 차익을 합하려고 했다. 
   처음 원소(0번째)와 그 다음의 모든 원소들(1~n-1)원소를 비교하고 다음에는 처음원소(1번째)와 그 다음의 모든 원소(2~n-1)과 비교해서
   처음 원소와 최대값을 가진 원소의 차익을 합하는 방식으로 진행하려고 했다. 시간복잡도가 좋지 않은 로직이지만, 매우 직관적이어서 이 알고리즘을 선택하려고 하였으나,,,
   알고보니, 입력받을 수 있는 매매가의 수가 백만이나 된다는 것이다.ㅋㅋ 그래서 바로 포기하고 다른 로직을 생각하게 되었다. 
   그래서 결국 선택한 로직은 매매가를 배열로 받고, 배열의 맨 뒤 원소 부터 접근해서 각 원소들을 비교해 나가면서 차익을 계산하는 것이었다. (배열의 맨 뒤 요소부터 접근하게 된 것은, 이전에 이와 비슷한 문제를 접해보았기 때문이다.)
   배열의 맨뒤 요소를 먼저 최대값(max)으로 잡고 최대값보다 작은 원소가 나오면 차익을 sum에 누적해서 합하고, 최대값보다 더 큰 원소가 나오면 그 값을 최대값으로 바꿔준다.
   이렇게 하면 되는데,,, 계속 제출이 실패해서 댓글로 힌트를 보니, Long을 하염없이 많이 달아둔 분을 발견했고 설마해서 보니, 매매가가 만원 이하고, 배열의 수가 백만개 이니, int의 범위를 충분히 벗어나겠구나 싶었다. 그래서 int sum -> long sum으로 바꿔서 제출을 하니 답안이 제출되었다!

   주저리 써놧지만, 결론 :  배열의 맨 뒤 원소 부터 접근해서 각 원소들을 비교해 나가면서 최대값과 각 원소의 차익을 계산, 만약 최대값보다 더 큰 값이 나오면 최대값을 변경해주고 다시 비교하면서 차익을 계산. 

6. 코드의 주요 부분을 간단히 설명해주세요
   답) "if(max<arr[i])" 으로 새로 등장하는 최대값을 계속해서 찾아주고 있다면 변경해준다.

7. 코드를 최적화 했다면 어떤 목적으로 최적화를 하셨나요?
   답) 

8. 코드를 테스트 할 때 어떤 케이스를 고려했나요?
   답) 판매할 때, 모두 이득인 경우, 모두 손해인 경우, 일부만 이득인 경우

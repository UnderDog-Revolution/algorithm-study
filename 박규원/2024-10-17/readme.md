1. 이 문제를 선택한 이유를 알려주세요(간단하게 설명해도 좋아요)
   답) 코테 준비를 위한 문자열 다루기에 익숙해지기 위해서, 그런데 dfs,bfs로 푼사람이 많더라...

2. 문제의 난이도는 어떻게 느껴지셨나요?
   답) 프로그래머스 Lv2

3. 문제를 처음 봤을 때 어떻게 접근하셨나요?
   답) 사람 주변에 사람,칸막이 테이블을 조회하여 맨해튼 거리를 검사하려고 하였다

4. 알고리즘 설계하는 데 걸린 시간은 어느 정도였나요?
   답) 1day+

5. 문제 해결 시 어려운 점이 있었나요? 있었다면, 어떻게 해결했나요?
   답) 처음부터 사람좌표 주변, 사람, 칸막이를 조사하려고 하니 조사할게 너무 많았고, 검증해야하는 로직이 너무 복잡해졌다. 그러니 시야가 너무 좁아져서 계속해서 사람과 칸막이만 조사하고 맨해튼 거리를 측정하려고 하였다. 그래서 책의 힌트를 조금 빌리니, 생각해보니 사람좌표 주변의 사람과, 빈테이블만 조사한다면 간단하게 로직 작성이 가능하였다. 상하좌우에 있는 사람을 체크하면 맨해튼 거리 1에 있는 사람은 확인이 되고, 빈테이블을 조사하면, 빈테이블 상하좌우의 사람만 체크하면 맨해튼 거리 2에 있는 사람이 확인이 된다. 만약, 기존처럼 빈테이블이 아닌 칸막이를 조사하게 되면, 칸막이의 상하좌우에 사람이 있는 것을 확인하더라도 그사람이 맨해튼 거리 2 규칙에 위반되는 사람인지 아닌지 구별이 불가능하다. 왜냐하면 칸막이의 대각선에 칸막이가 있는지 없는지 조사를 또 해주어야 그 사람이 맨해튼 거리에 위반되는 사람인지 아닌지 구분이 가능하기 때문이다.

6. 코드의 주요 부분을 간단히 설명해주세요
   답) 맨해튼 거리 1에 위치하는 사람을 찾기 위해 상하좌우를 검사하는 checkD_one, 맨해튼 거리 2 위치하는 사람을 찾는 checkD_two
   빈테이블 주변(상하좌우)의 사람을 찾는 checkP_count함수.

7. 코드를 최적화 했다면 어떤 목적으로 최적화를 하셨나요?
   답) 원하는 조건에 달성하면 바로 반복문을 탈출하도록 하였다. 하지만 checkP_count 함수에서 기준이 되는 사람좌표도 카운트 하게 되어, 쓸모없는 카운트 연산이 더 들어가게 되어 비효율적인 것이 문제이다.

8. 코드를 테스트 할 때 어떤 케이스를 고려했나요?
   답) 사람이 한 명도 없는 경우, 상하좌우에 있는 사람, 맨해튼 거리 2에 위치하지만 맨해튼 거리 1위치에 빈 테이블이 존재하는 사람.